#!/usr/bin/env python3
"""
Weak Cryptography Exploitation
Target: {{ target }}
Algorithm: {{ algorithm }}
"""

import hashlib
import base64
import itertools
from Crypto.Cipher import DES, AES
from Crypto.PublicKey import RSA
import binascii

# Configuration
# Configuration
TARGET_DATA = "{{ target_data }}"
ALGORITHM = "{{ algorithm }}"
KEY = "{{ key }}"  # If known
WORDLIST = "{{ wordlist_path | default('/usr/share/wordlists/rockyou.txt') }}"

class WeakCryptoExploit:
    def __init__(self):
        self.target_data = TARGET_DATA
        self.algorithm = ALGORITHM
        self.key = KEY

    def exploit_weak_hash(self):
        """Exploit weak hash algorithms"""
        if self.algorithm.upper() in ['MD5', 'SHA1']:
            print(f"[*] Exploiting weak hash: {self.algorithm}")

            # Try rainbow table attack
            self.rainbow_table_attack()

            # Try dictionary attack
            self.dictionary_attack()

            # Try brute force for short passwords
            self.brute_force_attack()

    def exploit_weak_encryption(self):
        """Exploit weak encryption algorithms"""
        if self.algorithm.upper() == 'DES':
            print("[*] Exploiting DES encryption")
            self.des_attack()
        elif self.algorithm.upper() == 'RC4':
            print("[*] Exploiting RC4 encryption")
            self.rc4_attack()
        elif 'ECB' in self.algorithm.upper():
            print("[*] Exploiting ECB mode")
            self.ecb_attack()

    def rainbow_table_attack(self):
        """Perform rainbow table attack"""
        print("[*] Attempting rainbow table attack...")

        # Common password hashes
        rainbow_table = {
            'MD5': {
                '5f4dcc3b5aa765d61d8327deb882cf99': 'password',
                '827ccb0eea8a706c4c34a16891f84e7b': '12345',
                'e10adc3949ba59abbe56e057f20f883e': '123456',
                '25d55ad283aa400af464c76d713c07ad': '12345678',
                'd8578edf8458ce06fbc5bb76a58c5ca4': 'qwerty'
            },
            'SHA1': {
                '5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8': 'password',
                '7c4a8d09ca3762af61e59520943dc26494f8941b': '123456',
                '20eabe5d64b0e216796e834f52d61fd0b70332fc': '1234567',
                '7c222fb2927d828af22f592134e8932480637c0d': '12345678'
            }
        }

        if self.algorithm.upper() in rainbow_table:
            if self.target_data in rainbow_table[self.algorithm.upper()]:
                password = rainbow_table[self.algorithm.upper()][self.target_data]
                print(f"[+] Password found: {password}")
                return password

        print("[-] Password not found in rainbow table")
        return None

    def dictionary_attack(self):
        """Perform dictionary attack"""
        print("[*] Attempting dictionary attack...")

        try:
            with open(WORDLIST, 'r', encoding='utf-8', errors='ignore') as f:
                for line in f:
                    password = line.strip()

                    # Compute hash
                    if self.algorithm.upper() == 'MD5':
                        hash_value = hashlib.md5(password.encode()).hexdigest()
                    elif self.algorithm.upper() == 'SHA1':
                        hash_value = hashlib.sha1(password.encode()).hexdigest()
                    elif self.algorithm.upper() == 'SHA256':
                        hash_value = hashlib.sha256(password.encode()).hexdigest()
                    else:
                        continue

                    if hash_value == self.target_data:
                        print(f"[+] Password found: {password}")
                        return password

        except FileNotFoundError:
            print(f"[-] Wordlist not found: {WORDLIST}")

        print("[-] Password not found in dictionary")
        return None

    def brute_force_attack(self, max_length=6):
        """Perform brute force attack on short passwords"""
        print(f"[*] Attempting brute force attack (max length: {max_length})...")

        charset = 'abcdefghijklmnopqrstuvwxyz0123456789'

        for length in range(1, max_length + 1):
            for password_tuple in itertools.product(charset, repeat=length):
                password = ''.join(password_tuple)

                # Compute hash
                if self.algorithm.upper() == 'MD5':
                    hash_value = hashlib.md5(password.encode()).hexdigest()
                elif self.algorithm.upper() == 'SHA1':
                    hash_value = hashlib.sha1(password.encode()).hexdigest()
                else:
                    continue

                if hash_value == self.target_data:
                    print(f"[+] Password found: {password}")
                    return password

        print("[-] Password not found via brute force")
        return None

    def des_attack(self):
        """Attack DES encryption"""
        print("[*] Analyzing DES encryption...")

        if len(self.key) != 8:
            print("[-] DES key must be 8 bytes")
            return

        try:
            # Decrypt with known key
            cipher = DES.new(self.key.encode(), DES.MODE_ECB)
            decrypted = cipher.decrypt(bytes.fromhex(self.target_data))
            print(f"[+] Decrypted data: {decrypted}")

            # Check for weak keys
            weak_keys = [
                b'\x01\x01\x01\x01\x01\x01\x01\x01',
                b'\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE',
                b'\x1F\x1F\x1F\x1F\x0E\x0E\x0E\x0E',
                b'\xE0\xE0\xE0\xE0\xF1\xF1\xF1\xF1'
            ]

            if self.key.encode() in weak_keys:
                print("[!] Weak DES key detected!")

        except Exception as e:
            print(f"[-] DES decryption failed: {e}")

    def rc4_attack(self):
        """Attack RC4 encryption"""
        print("[*] Analyzing RC4 encryption...")

        # RC4 implementation
        def rc4(key, data):
            S = list(range(256))
            j = 0

            # Key scheduling
            for i in range(256):
                j = (j + S[i] + key[i % len(key)]) % 256
                S[i], S[j] = S[j], S[i]

            # Pseudo-random generation
            i = j = 0
            result = []

            for byte in data:
                i = (i + 1) % 256
                j = (j + S[i]) % 256
                S[i], S[j] = S[j], S[i]
                K = S[(S[i] + S[j]) % 256]
                result.append(byte ^ K)

            return bytes(result)

        try:
            # Decrypt with known key
            key_bytes = self.key.encode()
            data_bytes = bytes.fromhex(self.target_data)
            decrypted = rc4(key_bytes, data_bytes)
            print(f"[+] Decrypted data: {decrypted}")

            # Check for weak key patterns
            if len(set(key_bytes)) < len(key_bytes) / 2:
                print("[!] Weak RC4 key detected - low entropy!")

        except Exception as e:
            print(f"[-] RC4 decryption failed: {e}")

    def ecb_attack(self):
        """Attack ECB mode encryption"""
        print("[*] Analyzing ECB mode encryption...")

        try:
            data_bytes = bytes.fromhex(self.target_data)
            block_size = 16  # AES block size

            # Check for repeating blocks
            blocks = [data_bytes[i:i+block_size] for i in range(0, len(data_bytes), block_size)]
            unique_blocks = set(blocks)

            if len(unique_blocks) < len(blocks):
                print("[!] ECB mode detected - repeating blocks found!")
                print(f"[*] Total blocks: {len(blocks)}, Unique blocks: {len(unique_blocks)}")

                # Find repeating patterns
                block_count = {}
                for block in blocks:
                    block_hex = binascii.hexlify(block).decode()
                    block_count[block_hex] = block_count.get(block_hex, 0) + 1

                print("[*] Repeating blocks:")
                for block_hex, count in block_count.items():
                    if count > 1:
                        print(f"  Block {block_hex}: {count} occurrences")

        except Exception as e:
            print(f"[-] ECB analysis failed: {e}")

    def padding_oracle_attack(self):
        """Perform padding oracle attack"""
        print("[*] Attempting padding oracle attack...")
        # This would require an actual oracle to test padding
        print("[-] Padding oracle attack requires live oracle endpoint")

    def analyze_entropy(self):
        """Analyze entropy of encrypted data"""
        print("[*] Analyzing entropy...")

        try:
            data_bytes = bytes.fromhex(self.target_data)

            # Calculate entropy
            byte_counts = {}
            for byte in data_bytes:
                byte_counts[byte] = byte_counts.get(byte, 0) + 1

            entropy = 0
            for count in byte_counts.values():
                probability = count / len(data_bytes)
                entropy -= probability * (probability.bit_length() - 1)

            print(f"[*] Entropy: {entropy:.4f} bits per byte")

            if entropy < 7.0:
                print("[!] Low entropy detected - possible weak encryption")
            else:
                print("[+] High entropy - likely strong encryption")

        except Exception as e:
            print(f"[-] Entropy analysis failed: {e}")

def main():
    print(f"[*] Weak Cryptography Exploitation")
    print(f"[*] Target: {TARGET_DATA}")
    print(f"[*] Algorithm: {ALGORITHM}")

    exploit = WeakCryptoExploit()

    # Determine attack type
    if ALGORITHM.upper() in ['MD5', 'SHA1', 'SHA256']:
        exploit.exploit_weak_hash()
    elif ALGORITHM.upper() in ['DES', 'RC4', 'ECB']:
        exploit.exploit_weak_encryption()
    else:
        print(f"[-] Unknown algorithm: {ALGORITHM}")

    # Analyze entropy
    exploit.analyze_entropy()

if __name__ == "__main__":
    main()