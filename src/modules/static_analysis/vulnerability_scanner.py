# src/modules/static_analysis/vulnerability_scanner.py
import os
import re
import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Any

class VulnerabilityScanner:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.patterns = self._load_patterns()

    def _load_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load vulnerability patterns from configuration"""
        patterns_file = Path('data/patterns/vulnerabilities.json')

        if patterns_file.exists():
            with open(patterns_file, 'r') as f:
                return json.load(f)
        else:
            # Default patterns
            return {
                'android': {
                    'sql_injection': [
                        {
                            'pattern': r'rawQuery\s*\(',
                            'severity': 'High',
                            'description': 'Potential SQL injection vulnerability with rawQuery'
                        },
                        {
                            'pattern': r'execSQL\s*\([^,]+\+',
                            'severity': 'High',
                            'description': 'SQL query concatenation detected'
                        }
                    ],
                    'insecure_storage': [
                        {
                            'pattern': r'MODE_WORLD_READABLE|MODE_WORLD_WRITEABLE',
                            'severity': 'High',
                            'description': 'World readable/writable file permissions'
                        },
                        {
                            'pattern': r'getSharedPreferences\s*\([^,]+,\\s*[0-3]\\)',
                            'severity': 'Medium',
                            'description': 'Potentially insecure SharedPreferences mode'
                        }
                    ],
                    'weak_crypto': [
                        {
                            'pattern': r'(MD5|SHA1|DES)\\s*\\(',
                            'severity': 'High',
                            'description': 'Weak cryptographic algorithm detected'
                        },
                        {
                            'pattern': r'Cipher\\.getInstance\\s*\\(\\s*["\']AES["\']\\s*\\)',
                            'severity': 'Medium',
                            'description': 'AES without mode specification (defaults to ECB)'
                        }
                    ],
                    'webview_issues': [
                        {
                            'pattern': r'setJavaScriptEnabled\\s*\\(\\s*true\\s*\\)',
                            'severity': 'Medium',
                            'description': 'JavaScript enabled in WebView'
                        },
                        {
                            'pattern': r'addJavascriptInterface\\s*\\(',
                            'severity': 'High',
                            'description': 'JavaScript interface added to WebView'
                        },
                        {
                            'pattern': r'setAllowFileAccess\\s*\\(\\s*true\\s*\\)',
                            'severity': 'High',
                            'description': 'File access enabled in WebView'
                        }
                    ],
                    'intent_vulnerabilities': [
                        {
                            'pattern': r'getSerializableExtra\\s*\\(',
                            'severity': 'Medium',
                            'description': 'Deserializing untrusted data from Intent'
                        },
                        {
                            'pattern': r'startActivity\\s*\\([^)]*getIntent\\s*\\(\\)',
                            'severity': 'Medium',
                            'description': 'Potential Intent redirection vulnerability'
                        }
                    ],
                    'logging_issues': [
                        {
                            'pattern': r'Log\\.(d|e|i|v|w)\\s*\\([^,]+,\\s*[^)]*(?:password|token|key|secret)',
                            'severity': 'Medium',
                            'description': 'Sensitive data potentially logged'
                        }
                    ]
                },
                'ios': {
                    'insecure_storage': [
                        {
                            'pattern': r'NSUserDefaults.*(?:password|token|key)',
                            'severity': 'High',
                            'description': 'Sensitive data stored in NSUserDefaults'
                        },
                        {
                            'pattern': r'writeToFile:.*atomically:\\s*YES',
                            'severity': 'Medium',
                            'description': 'Data written to file without encryption'
                        }
                    ],
                    'weak_crypto': [
                        {
                            'pattern': r'CC_MD5|CC_SHA1',
                            'severity': 'High',
                            'description': 'Weak hash function used'
                        },
                        {
                            'pattern': r'kCCAlgorithmDES',
                            'severity': 'High',
                            'description': 'Weak encryption algorithm (DES) used'
                        }
                    ],
                    'url_scheme': [
                        {
                            'pattern': r'handleOpenURL:|application:openURL:',
                            'severity': 'Medium',
                            'description': 'URL scheme handler implementation'
                        }
                    ],
                    'keychain_issues': [
                        {
                            'pattern': r'kSecAttrAccessibleAlways',
                            'severity': 'High',
                            'description': 'Keychain item accessible when device is locked'
                        }
                    ]
                }
            }

    def scan(self, directory: Path) -> List[Dict[str, Any]]:
        """Scan directory for vulnerabilities with improved Java file handling"""
        vulnerabilities = []

        # Check for Java files using multiple patterns
        java_patterns = ['**/*.java', '**/src/**/*.java', '**/sources/**/*.java', '**/java/**/*.java', '**/smali/**/*.smali']

        # Log detailed info about the extraction directory
        self.logger.info(f"Scanning directory: {directory}")

        # Check directory structure
        for root, dirs, files in os.walk(directory):
            for dir_name in dirs[:10]:  # List first 10 directories
                self.logger.info(f"Found directory: {os.path.join(root, dir_name)}")

        # Count each type of file
        java_files = []
        smali_files = []
        xml_files = []

        for pattern in java_patterns:
            found_files = list(directory.glob(pattern))
            java_files.extend(found_files)
            self.logger.info(f"Found {len(found_files)} Java files with pattern: {pattern}")

        smali_files = list(directory.glob('**/*.smali'))
        xml_files = list(directory.glob('**/*.xml'))

        self.logger.info(f"Total files found: {len(java_files)} Java files, {len(smali_files)} Smali files, {len(xml_files)} XML files")

        # If no Java files but we have Smali files, try decompiling
        if len(java_files) < 10 and smali_files:
            self.logger.info("Few or no Java files found but Smali files exist. Attempting to convert Smali to Java...")
            try:
                # Create a directory for decompiled Java
                java_dir = directory / "decompiled_java"
                java_dir.mkdir(exist_ok=True)

                # Try using jadx on the original APK file if available
                apk_files = list(Path(os.path.dirname(directory)).glob('*.apk'))
                if apk_files:
                    apk_path = apk_files[0]
                    self.logger.info(f"Found APK: {apk_path}, using jadx to decompile directly")
                    try:
                        subprocess.run(['jadx', '-d', str(java_dir), str(apk_path)],
                                       check=True, capture_output=True, text=True)

                        # Check if we got Java files
                        new_java_files = list(java_dir.glob('**/*.java'))
                        self.logger.info(f"Decompiled {len(new_java_files)} Java files with jadx")
                        java_files.extend(new_java_files)
                    except Exception as e:
                        self.logger.error(f"Failed to run jadx: {e}")

                        # Try using dex2jar if jadx fails
                        try:
                            self.logger.info("Trying dex2jar as fallback...")
                            jar_path = directory / "classes.jar"
                            subprocess.run(['d2j-dex2jar', '-o', str(jar_path), str(apk_path)],
                                           check=True, capture_output=True, text=True)

                            # Try to extract jar contents
                            self.logger.info(f"Extracting jar file: {jar_path}")
                            jar_dir = directory / "jar_contents"
                            jar_dir.mkdir(exist_ok=True)
                            subprocess.run(['jar', 'xf', str(jar_path), '-C', str(jar_dir)],
                                           check=True, capture_output=True, text=True)

                            # Check if we got class files
                            class_files = list(jar_dir.glob('**/*.class'))
                            self.logger.info(f"Extracted {len(class_files)} class files from jar")

                            # Try to decompile classes with javap
                            for class_file in class_files[:10]:  # Process first 10 as example
                                try:
                                    java_output = directory / "javap_output"
                                    java_output.mkdir(exist_ok=True)
                                    output_file = java_output / f"{class_file.stem}.java"

                                    with open(output_file, 'w') as f:
                                        proc = subprocess.run(['javap', '-c', str(class_file)],
                                                              capture_output=True, text=True)
                                        f.write(proc.stdout)

                                    java_files.append(output_file)
                                except Exception as e:
                                    self.logger.error(f"Failed to decompile class {class_file}: {e}")
                        except Exception as e:
                            self.logger.error(f"Failed with dex2jar: {e}")
            except Exception as e:
                self.logger.error(f"Failed to create decompiled Java directory: {e}")

        # Process smali files directly if we have no Java
        if len(java_files) < 5 and smali_files:
            self.logger.info("Processing smali files directly since Java files are insufficient")
            for smali_file in smali_files[:100]:  # Limit to 100 files for efficiency
                try:
                    # Read smali file
                    with open(smali_file, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()

                    # Scan for vulnerabilities in smali
                    self.logger.info(f"Scanning smali file: {smali_file}")
                    for platform, vulnerability_types in self.patterns.items():
                        for vuln_type, patterns in vulnerability_types.items():
                            for pattern_info in patterns:
                                # Convert Java patterns to smali patterns
                                smali_pattern = pattern_info['pattern']

                                # Some basic conversions for smali vs java patterns
                                smali_pattern = smali_pattern.replace('\\(', '\\s*\\(')
                                smali_pattern = smali_pattern.replace('.', '/')

                                matches = re.finditer(smali_pattern, content, re.IGNORECASE)
                                for match in matches:
                                    vulnerabilities.append({
                                        'type': vuln_type,
                                        'severity': pattern_info['severity'],
                                        'description': pattern_info['description'],
                                        'file': str(smali_file),
                                        'line': content[:match.start()].count('\n') + 1,
                                        'code': match.group(0)
                                    })
                except Exception as e:
                    self.logger.error(f"Error processing smali file {smali_file}: {e}")

        # Now scan all Java files
        for java_file in java_files[:100]:  # Limit to 100 files for efficiency
            try:
                self.logger.info(f"Scanning Java file: {java_file}")
                with open(java_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()

                # Scan for vulnerabilities in Java code
                for platform, vulnerability_types in self.patterns.items():
                    for vuln_type, patterns in vulnerability_types.items():
                        for pattern_info in patterns:
                            matches = re.finditer(pattern_info['pattern'], content, re.IGNORECASE)
                            for match in matches:
                                vulnerabilities.append({
                                    'type': vuln_type,
                                    'severity': pattern_info['severity'],
                                    'description': pattern_info['description'],
                                    'file': str(java_file),
                                    'line': content[:match.start()].count('\n') + 1,
                                    'code': match.group(0)
                                })
            except Exception as e:
                self.logger.error(f"Error scanning Java file {java_file}: {e}")

        # Continue with scanning other file types
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith(('.xml', '.js', '.kt')):
                    file_path = Path(root) / file
                    vulnerabilities.extend(self._scan_file(file_path))

        return vulnerabilities

    def _scan_file(self, file_path: Path) -> List[Dict[str, Any]]:
        """Scan a single file for vulnerabilities"""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

                # Determine platform from file path
                is_android = 'android' in str(file_path).lower() or file_path.suffix in ['.java', '.xml', '.kt']
                is_ios = 'ios' in str(file_path).lower() or file_path.suffix in ['.swift', '.m', '.h']

                platform_keys = []
                if is_android:
                    platform_keys.append('android')
                if is_ios:
                    platform_keys.append('ios')

                # If no specific platform identified, check both
                if not platform_keys:
                    platform_keys = ['android', 'ios']

                # Check patterns for identified platforms
                for platform in platform_keys:
                    if platform in self.patterns:
                        for vuln_type, patterns in self.patterns[platform].items():
                            for pattern_info in patterns:
                                regex_pattern = pattern_info['pattern']
                                matches = re.finditer(regex_pattern, content, re.IGNORECASE)
                                for match in matches:
                                    vulnerabilities.append({
                                        'type': vuln_type,
                                        'severity': pattern_info['severity'],
                                        'description': pattern_info['description'],
                                        'file': str(file_path),
                                        'line': content[:match.start()].count('\n') + 1,
                                        'code': match.group(0)
                                    })

        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {e}")

        return vulnerabilities

    def find_secrets(self, directory: Path) -> List[Dict[str, Any]]:
        """Find hardcoded secrets in the codebase"""
        secrets = []
        secret_patterns = {
            'AWS Access Key': r'(A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}',
            'AWS Secret Key': r'(?i)aws(.{0,20})?(?-i)[\'"]?([0-9a-zA-Z/+]{40})[\'"]?',
            'Firebase': r'AIza[0-9A-Za-z_-]{35}',
            'Google OAuth': r'[0-9]+-[0-9A-Za-z_]{32}\.apps\.googleusercontent\.com',
            'Private Key': r'-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----',
            'GitHub Token': r'gh[pousr]_[A-Za-z0-9_]{36,255}',
            'Google API Key': r'AIza[0-9A-Za-z_-]{35}',
            'JWT Token': r'ey[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*',
            'Slack Token': r'xox[abpr]-[0-9a-zA-Z]{10,48}',
            'Generic API Key': r'(?i)(api_key|apikey|api-key)\s*[:=]\s*[\'"]?([a-zA-Z0-9_-]{20,})[\'"]?',
            'Generic Secret': r'(?i)(secret|password|passwd|pwd)\s*[:=]\s*[\'"]?([^\s\'"]{8,})[\'"]?'
        }

        # Log where we're searching for secrets
        self.logger.info(f"Searching for secrets in directory: {directory}")

        # File extensions to scan
        target_extensions = {
            '.java', '.kt', '.xml', '.json', '.properties', '.yml', '.yaml',
            '.js', '.ts', '.jsx', '.tsx', '.vue', '.html', '.css',
            '.py', '.rb', '.php', '.swift', '.m', '.h', '.smali',
            '.conf', '.config', '.ini', '.env', '.sh', '.bash'
        }

        # Files to ignore
        ignore_patterns = {
            'node_modules', 'build', 'dist', '.git', '__pycache__',
            'vendor', 'target', 'bin', 'obj', 'packages'
        }

        file_count = 0

        for root, dirs, files in os.walk(directory):
            # Skip ignored directories
            dirs[:] = [d for d in dirs if d not in ignore_patterns]

            for file in files:
                file_path = Path(root) / file

                # Skip files that are too large
                try:
                    if file_path.stat().st_size > 10 * 1024 * 1024:  # Skip files larger than 10MB
                        self.logger.info(f"Skipping large file: {file_path}")
                        continue
                except:
                    continue

                # Process files with target extensions
                if file_path.suffix.lower() in target_extensions:
                    file_count += 1
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()

                            for secret_type, pattern in secret_patterns.items():
                                matches = re.finditer(pattern, content)
                                for match in matches:
                                    value = match.group(0)

                                    # Skip common false positives
                                    if any(fp in value.lower() for fp in ['example', 'test', 'placeholder', 'sample']):
                                        continue

                                    # Try to get surrounding context
                                    line_number = content[:match.start()].count('\n') + 1

                                    secrets.append({
                                        'type': secret_type,
                                        'value': value,
                                        'file': str(file_path),
                                        'line': line_number
                                    })

                    except Exception as e:
                        self.logger.error(f"Error searching secrets in {file_path}: {e}")

        self.logger.info(f"Searched {file_count} files for secrets, found {len(secrets)}")
        return secrets