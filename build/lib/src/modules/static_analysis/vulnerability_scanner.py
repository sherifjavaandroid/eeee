# import os
# import subprocess
# import tempfile
# import zipfile
# import logging
# from pathlib import Path
# from typing import Dict, List, Any
# import xml.etree.ElementTree as ET
#
# class APKAnalyzer:
#     def __init__(self, apk_path: str):
#         self.apk_path = Path(apk_path)
#         self.extracted_path = None
#         self.logger = logging.getLogger(__name__)
#         self.manifest_data = None
#         self.package_name = None
#
#     def extract(self) -> Path:
#         """Extract APK contents"""
#         self.extracted_path = Path(tempfile.mkdtemp())
#
#         try:
#             # Extract using apktool
#             subprocess.run([
#                 'apktool', 'd', '-f', str(self.apk_path),
#                 '-o', str(self.extracted_path)
#             ], check=True, capture_output=True)
#
#             self.logger.info(f"APK extracted to: {self.extracted_path}")
#             return self.extracted_path
#
#         except subprocess.CalledProcessError as e:
#             self.logger.error(f"Failed to extract APK: {e}")
#             raise
#
#     def get_app_info(self) -> Dict[str, Any]:
#         """Get basic app information"""
#         info = {}
#
#         try:
#             # Use aapt to get app info
#             result = subprocess.run([
#                 'aapt', 'dump', 'badging', str(self.apk_path)
#             ], capture_output=True, text=True)
#
#             output = result.stdout
#
#             # Parse package name
#             if "package: name='" in output:
#                 self.package_name = output.split("package: name='")[1].split("'")[0]
#                 info['package_name'] = self.package_name
#
#             # Parse version
#             if "versionName='" in output:
#                 info['version'] = output.split("versionName='")[1].split("'")[0]
#
#             # Parse permissions
#             permissions = []
#             for line in output.splitlines():
#                 if line.startswith('uses-permission:'):
#                     perm = line.split("'")[1]
#                     permissions.append(perm)
#             info['permissions'] = permissions
#
#             return info
#
#         except Exception as e:
#             self.logger.error(f"Failed to get app info: {e}")
#             return info
#
#     def analyze_manifest(self) -> List[Dict[str, Any]]:
#         """Analyze AndroidManifest.xml for security issues"""
#         issues = []
#         manifest_path = self.extracted_path / 'AndroidManifest.xml'
#
#         if not manifest_path.exists():
#             self.logger.error("AndroidManifest.xml not found")
#             return issues
#
#         try:
#             tree = ET.parse(manifest_path)
#             root = tree.getroot()
#
#             # Check for debuggable flag
#             app_elem = root.find('.//application')
#             if app_elem is not None:
#                 debuggable = app_elem.get('{http://schemas.android.com/apk/res/android}debuggable')
#                 if debuggable == 'true':
#                     issues.append({
#                         'type': 'Debuggable App',
#                         'severity': 'High',
#                         'description': 'Application is debuggable',
#                         'location': 'AndroidManifest.xml'
#                     })
#
#                 # Check allowBackup
#                 allow_backup = app_elem.get('{http://schemas.android.com/apk/res/android}allowBackup')
#                 if allow_backup == 'true':
#                     issues.append({
#                         'type': 'Backup Allowed',
#                         'severity': 'Medium',
#                         'description': 'Application allows backup',
#                         'location': 'AndroidManifest.xml'
#                     })
#
#             # Check for exported components
#             for component in ['activity', 'service', 'receiver', 'provider']:
#                 for elem in root.findall(f'.//{component}'):
#                     exported = elem.get('{http://schemas.android.com/apk/res/android}exported')
#                     if exported == 'true':
#                         name = elem.get('{http://schemas.android.com/apk/res/android}name')
#                         issues.append({
#                             'type': 'Exported Component',
#                             'severity': 'Medium',
#                             'description': f'Exported {component}: {name}',
#                             'location': 'AndroidManifest.xml'
#                         })
#
#             return issues
#
#         except Exception as e:
#             self.logger.error(f"Failed to analyze manifest: {e}")
#             return issues
#
#     def get_extracted_path(self) -> Path:
#         """Get the path to extracted APK contents"""
#         return self.extracted_path
#
#     def get_package_name(self) -> str:
#         """Get the package name"""
#         if not self.package_name:
#             self.get_app_info()
#         return self.package_name



import os
import re
import json
import logging
from pathlib import Path
from typing import Dict, List, Any

class VulnerabilityScanner:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.patterns = self._load_patterns()

    def _load_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load vulnerability patterns from configuration"""
        patterns_file = Path('data/patterns/vulnerabilities.json')

        if patterns_file.exists():
            with open(patterns_file, 'r') as f:
                return json.load(f)
        else:
            # Default patterns
            return {
                'sql_injection': [
                    {
                        'pattern': r'rawQuery\s*\(',
                        'severity': 'High',
                        'description': 'Potential SQL injection vulnerability'
                    },
                    {
                        'pattern': r'execSQL\s*\([^,]+\+',
                        'severity': 'High',
                        'description': 'SQL query concatenation detected'
                    }
                ],
                'weak_crypto': [
                    {
                        'pattern': r'(MD5|SHA1|DES)\s*\(',
                        'severity': 'High',
                        'description': 'Weak cryptographic algorithm used'
                    }
                ],
                'hardcoded_secrets': [
                    {
                        'pattern': r'(password|api_key|secret)\s*=\s*["\'][^"\']+["\']',
                        'severity': 'High',
                        'description': 'Hardcoded secret detected'
                    }
                ],
                'insecure_storage': [
                    {
                        'pattern': r'MODE_WORLD_READABLE|MODE_WORLD_WRITEABLE',
                        'severity': 'High',
                        'description': 'Insecure file permissions'
                    }
                ],
                'webview_issues': [
                    {
                        'pattern': r'setJavaScriptEnabled\s*\(\s*true\s*\)',
                        'severity': 'Medium',
                        'description': 'JavaScript enabled in WebView'
                    },
                    {
                        'pattern': r'addJavascriptInterface\s*\(',
                        'severity': 'High',
                        'description': 'JavaScript interface added to WebView'
                    }
                ]
            }

    def scan(self, directory: Path) -> List[Dict[str, Any]]:
        """Scan directory for vulnerabilities"""
        vulnerabilities = []

        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith(('.java', '.kt', '.xml', '.js')):
                    file_path = Path(root) / file
                    vulnerabilities.extend(self._scan_file(file_path))

        return vulnerabilities

    def _scan_file(self, file_path: Path) -> List[Dict[str, Any]]:
        """Scan a single file for vulnerabilities"""
        vulnerabilities = []

        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

                for vuln_type, patterns in self.patterns.items():
                    for pattern_info in patterns:
                        matches = re.finditer(pattern_info['pattern'], content)
                        for match in matches:
                            vulnerabilities.append({
                                'type': vuln_type,
                                'severity': pattern_info['severity'],
                                'description': pattern_info['description'],
                                'file': str(file_path),
                                'line': content[:match.start()].count('\n') + 1,
                                'code': match.group(0)
                            })

        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {e}")

        return vulnerabilities

    def find_secrets(self, directory: Path) -> List[Dict[str, Any]]:
        """Find hardcoded secrets in the codebase"""
        secrets = []
        secret_patterns = {
            'AWS': r'(A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}',
            'Firebase': r'AIza[0-9A-Za-z_-]{35}',
            'Google OAuth': r'[0-9]+-[0-9A-Za-z_]{32}\.apps\.googleusercontent\.com',
            'Private Key': r'-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----',
            'Generic API': r'[aA][pP][iI]_?[kK][eE][yY].*[\'\"]\s*[:=]\s*[\'\"]\w{32,45}[\'"]',
            'Generic Secret': r'[sS][eE][cC][rR][eE][tT].*[\'\"]\s*[:=]\s*[\'\"]\w{10,}[\'"]'
        }

        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith(('.java', '.kt', '.xml', '.js', '.json', '.properties')):
                    file_path = Path(root) / file

                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()

                            for secret_type, pattern in secret_patterns.items():
                                matches = re.finditer(pattern, content)
                                for match in matches:
                                    secrets.append({
                                        'type': secret_type,
                                        'value': match.group(0),
                                        'file': str(file_path),
                                        'line': content[:match.start()].count('\n') + 1
                                    })

                    except Exception as e:
                        self.logger.error(f"Error searching secrets in {file_path}: {e}")

        return secrets